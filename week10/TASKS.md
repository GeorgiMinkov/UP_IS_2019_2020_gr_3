# Задачи 1-6 са за хора които искат да упражняват още функции преди да се пуснат на рекурсия.

## TASK 1

Напишете функция, която разменя стойностите на две цели числа като използвате:
* Указатели - `void swap(int*, int*)`
    
* Псевдоними - `void swap(int&, int&)`

## TASK 2

Напишете функция с прототип `void print(int[], int)` , която изпечатва масив от цели числа, без да използва оператора []:
   * Отпред назад
   * Отзад напред
   
## TASK 3

Напишете функция с прототип `void max(int[], int, int*)` , коятo по подаден масив от цели числа намира най-голямото число
и го попълва като изходен параметър.

## TASK 4

Напишете функция с прототип `int replace(int x[], int size, int replaceWhat, int replaceWith)`,
която заменя всяко срещане на `replaceWhat` в масива `x` с `replaceWith`.

## TASK 5

Напишете функция с прототип `void reverse(int x[], int size)` , която инвертира елементите на едномерен масив `x`
с размер `size` , без да се използва операторът [].
   
## TASK 6

Напишете следните функции (без да се използва операторът []):

   * Функция с прототип `bool isSorted(int[], int)` , която приема като аргумент масив от
      цели числа и неговия размер и проверява дали той е сортиран във възходящ ред(всеки негов елемент е по-малък или равен от следващия).
      
   * Функция с прототип `bool allEven(int[], int)` , която приема като аргумент масив от
      цели числа и неговия размер и проверява дали всички негови елементи са четни числа.
   
   * Функция с прототип `bool containsPrimes(int[], int)` , която приема като аргумент масив от
      цели числа и неговия размер и проверява дали в масива се съдържа поне едно просто число.
 -------------------------------------------

# Упражнение 10 - Рекурсия

## TASK 0
Напишете рекурсивна функция с прототип `int sumOfDigits(int)` , която връща като резултат сборът от цифрите на цяло положително
число с променлива дължина.

`Пример:` 
``` C++
sumOfDigits(154) => 10
```

## TASK 1
Напишете рекурсивна функция с прототип int `recStrlen(const char*)` , която връща като резултат дължината на подадения низ.
	
`Пример:`
``` C++
recStrlen("Happy new year") => 14
```
  
## TASK 2
Напишете рекурсивна функция с прототип `int reverse(int)`, която обръща цяло число (от дадено число получава ново число,
в което цифрите са в обратен ред).

`Пример:`
```C++
invert(1123) => 3211
```

## TASK  3
Напишете рекурсивна функция `int factorial(int)` , която пресмята факториел от дадено цяло число.

`Пример:`
```C++
factorial(5) => 120
```

## TASK 4
Да се напише рекурсивна функция bool `areEqual(char* str1, char* str2)`, която проверява дали двата стринга са равни.

`Пример:`
```C++
areEqual("", "") -> true
```
```C++
areEqual("", "Hi") -> false
```
```C++
areEqual("Hello","Hello") -> true
```
```C++
areEqual("Hello", "Hi") -> false
```

## TASK 5
Напишете функция с прототип `void evaluate(const char*)`, която намира и изпечатва
   броят на малки и големи букви и броят на цифрите в даденият низ
   
`Пример:`
``` C++
evaluate("3 Doors Down") 
      => Брой малки букви: 7
         Брой големи букви: 2
         Брой цифри: 1
```

## TASK 6
Напишете функция с прототип bool `swapcase(char*)`, която променя всяка голяма
буква на малка и всяка малка на голяма в подадения низ

`Пример:`
``` C++
swapcase("Yellow Submarine") => yELLOW sUBMARINE
```

## TASK 7
Напишете функция с прототип `void findWords(const char*)`, която намира
най-дългата и най-късата дума от дадения низ. Ако има две или
повече думи с еднаква дължина, които са най-къси или най-дълги,
да се изпечата последната намерена дума

`Пример:`
``` C++
findWords("yesterday love was such an easy game to play")
      => Най-дълга дума: yesterday
         Най-къса дума: to
```

## TASK 8
 Напишете функция с прототип `void truncate(char* src, int n)`, която скъсява
подадения низ до низ с дължина n. Ако низът вече е по-къс от n, той
не трябва да се модифицира

`Пример:`
``` C++
truncate("The Dark Knight Rises", 15 ) => The Dark Knight
```

## TASK 9

Да се напише рекурсивна функция, която намира n-тото число от редицата на Фибоначи.
Пример: при n = 10 -> 55

## TASK 10
Да се напише рекурсивна функция, която проверява дали елементът x принадлежи на редицата a0, a1, ..., an-1. 

## TASK 11
Да се напише рекурсивна функция, която проверява дали редицата a0, a1, ..., an-1  се състои от различни елементи.

## TASK 12
Да се напише рекурсивна функция, която намира стойността  на  функцията на Акерман Ack(m, n), дефинирана за m >= 0 и n >= 0 по следния начин:  
		Ack(0, n) = n+1  
		Ack(m, 0) = Ack(m-1, 1), m > 0  
		Ack(m, n) = Ack(m-1, Ack(m, n-1)), m > 0, n > 0.
    
Пример:		
ack(0,3) = 4
ack(0,4) = 5
ack(1,0) = 2
ack(1,1) = 3
ack(2,0) = 3
ack(2,1) = 5

## TASK 13
Да се напише рекурсивна функция, която установява, дали в записа на естественото число n се съдържа цифрата k.   




 
